{"version":3,"file":"webx1.umd.js","sources":["../src/utils/rules.js","../src/index.js"],"sourcesContent":["const rules = {\n    isArray: (o) => {\n        return Array.isArray(o);\n    },\n    isString: (o) => {\n      return o !== null && typeof o === \"string\";\n    },\n    isEmptyObject: (o) => {\n      var name;\n      for (name in o) {\n        if (o.hasOwnProperty(name)) return false;\n      }\n      return true;\n    },\n    isFunc: (o) => {\n      return typeof o === \"function\";\n    },\n    isAsyncFunc: (fn) => {\n      return rules.isFunc(fn) && fn.constructor.name === \"AsyncFunction\";\n    },\n    isNode: (o) => {\n      return typeof Node === \"object\"\n        ? o instanceof Node\n        : o &&\n            typeof o === \"object\" &&\n            typeof o.nodeType === \"number\" &&\n            typeof o.nodeName === \"string\";\n    },\n    isElement: (o) => {\n      return typeof HTMLElement === \"object\"\n        ? o instanceof HTMLElement //DOM2\n        : o &&\n            typeof o === \"object\" &&\n            o !== null &&\n            o.nodeType === 1 &&\n            typeof o.nodeName === \"string\";\n    },\n  };\n\n  export default rules;","import rules from \"./utils/rules\";\n\nconst defaultOptions = {\n  global: \"$\",\n  appName: \"App\",\n  metaTitlePrepend: \"\",\n  routes: {},\n  notFoundRouteName: \"notfound\",\n  notFoundUrl: \"/notfound\",\n};\n\nexport default async (options) => {\n  let opts = Object.assign({}, defaultOptions, options);\n\n  let cache = {\n    routes: {\n      \"/\": () => ({\n        view: `<div>Webx Rocks!</div>`,\n      }),\n      notfound: () => ({\n        view: `<div>404 Not Found!</div>`,\n      }),\n      error: () => ({\n        view: \"<div>An error has occurred!</div>\",\n      }),\n    },\n  };\n\n  // routes\n  if (!rules.isEmptyObject(opts.routes)) {\n    // prevalidate routes\n    let routeErrors = {};\n    for (var x in opts.routes) {\n      if (opts.routes.hasOwnProperty(x)) {\n        if (!opts.routes[x].view) {\n          routeErrors[x] = [`A view property is required for route \"${x}\"`];\n        }\n      }\n    }\n    if (Object.keys(routeErrors).length) {\n      throw new Error(\"Invalid route configuration\", routeErrors);\n    }\n    cache.routes = opts.routes;\n  }\n\n  const getProxy = (app) => {\n    let builtins = {\n      setState: app.setState,\n      getState: app.getState,\n      dispatch: app.dispatch,\n      listen: app.listen,\n      refresh: app.refresh,\n    };\n\n    // Add plugin api's to proxy\n    return Object.keys(app._plugins).reduce((prev, next) => {\n      let plugin = app._plugins[next];\n      if (plugin.api) {\n        let ref = plugin.namespace ? plugin.namespace : plugin.name;\n        if (!prev[ref]) {\n          prev[ref] = plugin.api;\n        } else {\n          prev[ref] = Object.assign(prev[ref], plugin.api);\n        }\n      }\n      return prev;\n    }, builtins);\n  };\n\n  const app = {\n    el: document.body,\n    _currentPath: null,\n    _currentRoute: null,\n    _state: {},\n    _listeners: [],\n    _plugins: {},\n    routes: { ...cache.routes },\n    ok: true,\n    plugin: (plugin, options = {}) => {\n      if (!plugin.name) {\n        throw new Error(\"A plugin must have a name property.\");\n      }\n      if (!plugin.install || !rules.isFunc(plugin.install)) {\n        throw new Error(\"A plugin must define an install method.\");\n      }\n      if (app._plugins[plugin.name]) {\n        throw new Error(\n          `A plugin with the name: \"${plugin.name} is already registered.\"`\n        );\n      }\n      app._plugins[plugin.name] = plugin;\n      try {\n        let api = plugin.install(app, options);\n        if (api) {\n          app._plugins[plugin.name].api = api;\n          // Add to window global\n          if (plugin.global) {\n            if (!window[plugin.global]) {\n              window[plugin.global] = api;\n            } else {\n              window[plugin.global] = Object.assign(window[plugin.global], api);\n            }\n          }\n          // Update app context\n          app.ctx = getProxy(app);\n        }\n        if (options.installed && rules.isFunc(options.installed)) {\n          options.installed();\n        }\n      } catch (err) {\n        console.error(`Plugin \"${plugin.name}\" failed to install.`, err);\n        if (options.onError && rules.isFunc(options.onError)) {\n          options.onError(err);\n        }\n        delete app._plugins[plugin.name];\n      }\n    },\n    getState: (...args) => {\n      if (args.length) {\n        return app._state[args[0]];\n      }\n      return { ...app._state };\n    },\n    setState: (key, value) => {\n      let oldState = Object.freeze(JSON.parse(JSON.stringify(app._state)));\n      app._state[key] = value;\n      let newState = Object.freeze(JSON.parse(JSON.stringify(app._state)));\n      // change listeners\n      app._listeners.forEach((listener) => {\n        listener(\"stateChange\", newState, oldState, key, value);\n      });\n    },\n    replaceState: (newState) => {\n      let oldState = Object.freeze(JSON.parse(JSON.stringify(app._state)));\n      app._state = newState;\n      app._listeners.forEach((listener) => {\n        listener(\"stateChange\", newState, oldState, \"*\", newState);\n      });\n    },\n    dispatch: (type, ...args) => {\n      app._listeners.forEach((listener) => {\n        listener.apply(null, [type, ...args]);\n      });\n    },\n    listen: (handler) => {\n      if (rules.isFunc(handler)) {\n        app._listeners.push(handler);\n        return () => {\n          let idx = app._listeners.indexOf(handler);\n          if (idx !== -1) {\n            app._listeners.splice(idx, 1);\n          }\n        };\n      } else {\n        console.error(\"Listen handler must be a function\", handler);\n      }\n    },\n    refresh: () => {\n      app.navigate(app._currentPath, true, true)\n        .then(() => app.dispatch('refreshed', app._currentPath))      \n    },\n    renderView: async (view, state, meta) => {\n      if (!rules.isFunc(view)) {\n        throw new Error(\"renderView requires a function.\");\n      }\n\n      if (app.el.renderView && rules.isFunc(app.el.renderView)) {\n        try {\n          await app.el.renderView(view, state, meta);\n        } catch (err) {\n          console.error(\"render async view error\", err);\n        }\n\n        return;\n      }\n\n      try {\n        app.el.innerHTML = await view(state);\n      } catch (err) {\n        console.error(\"Render view errror\", err);\n      }\n\n      if (meta) {\n        document.title = `${opts.metaTitlePrepend}${meta.title}`;\n      }\n\n      app.dispatch('view-rendered', { detail: view });\n    },\n    initRoute: async (route, state) => {\n      const proxy = getProxy(app);\n\n      if (rules.isFunc(route.init)) {\n        await route.init(state, proxy, app.el);\n      }\n    },\n    unmountRoute: (route) => {\n      if (route && rules.isFunc(route.unmount)) {\n        route.unmount(getProxy(app));\n      }\n    },\n    routeInit: async (route, state) => {\n      if (opts.routeInit && rules.isFunc(opts.routeInit)) {\n        await opts.routeInit(route, state);\n      }\n    },\n    navigate: async (pathName, force, refreshOnly) => {\n      // don't fire same route unless forced\n      if (!force && app._currentPath && app._currentPath === pathName) {\n        return false;\n      }\n      const prevPath = app._currentPath;\n      app._currentPath = pathName;\n      let query = {};\n      let params = {};\n\n      const setRoute = async (path, xtra = {}) => {\n        let route = routes[path];\n\n        if (!route) {\n          route = routes[\"/notfound\"] || {\n            view: () => `<div class=\"page\">404 Not Found</div>`,\n          };\n        }\n\n        app._currentRoute = path;\n\n        query = location.search\n          .slice(1)\n          .split(\"&\")\n          .reduce((prev, curr) => {\n            let t = curr.split(\"=\");\n            prev[t[0]] = decodeURIComponent(t[1] || \"\");\n            return prev;\n          }, {});\n        let state = { ...app.getState(), ...xtra, query, path };\n\n        // Pre-render hook\n        if (!refreshOnly) {\n          try {\n            await app.routeInit(route, state);\n          } catch (err) {\n            console.error(\"Pre-render failed:\", err);\n          }\n        }\n\n        // Render view\n        try {\n          await app.renderView(route.view, state, route.meta);\n        } catch (err) {\n          console.error(\"Render view failed\", err);\n        }\n\n        // Initialize route\n        try {\n          await app.initRoute(route, state);\n        } catch (err) {\n          console.error(\n            `Init route for \"${route.name ? route.name : path}\" failed`,\n            err\n          );\n        }\n\n        const { params = {} } = xtra;\n\n        if (!refreshOnly) {\n          app._listeners.forEach((listener) => {\n            listener(\"pageChange\", {\n              from: prevPath,\n              to: app._currentRoute,\n              params,\n              query,\n            });\n          });\n        }\n      };\n\n      const { routes } = app;\n\n      // Unmount current route, if any\n      if (!refreshOnly) {\n        if (app._currentRoute) {\n          app.unmountRoute(app.routes[app._currentRoute]);\n        }\n      }\n\n      // exact match\n      if (routes[pathName]) {\n        app._currentRoute = pathName;\n        setRoute(pathName);\n        return { path: pathName, route: pathName, query, params };\n      }\n\n      // param route w/fuzzy match logic\n      let tokens = pathName.split(\"/\").slice(1);\n      let found = Object.keys(routes).filter((x) => {\n        return (\n          x.indexOf(`/${tokens[0]}`) !== -1 &&\n          x.split(\"/\").slice(1).length === tokens.length\n        );\n      })[0];\n\n      if (found) {\n        found\n          .split(\"/\")\n          .slice(2)\n          .forEach((n, x) => {\n            params[n.slice(1)] = tokens[x + 1];\n          });\n        setRoute(found, { params });\n        return { path: pathName, route: found, query, params };\n      }\n      // Not found\n      app._currentRoute = opts.notFoundRouteName;\n      setRoute(opts.notFoundUrl);\n      return { path: pathName, route: undefined, query, params };\n    },\n    boot: async () => {\n      // Runs on startup. Intended to be monkey patched in plugins.\n    },\n  };\n\n  const mount = async (el) => {\n    try {\n      if (rules.isString(el)) {\n        app.el = document.querySelector(el);\n        if (!app.el) {\n          throw new Error(`Invalid mount target: ${el}. Missing from the DOM.`);\n        }\n      } else {\n        if (!rules.isNode(el) || !rules.isElement(el)) {\n          throw new Error(\"Invalid DOM object for mount.\");\n        }\n        app.el = el;\n      }\n\n      if (rules.isFunc(opts.init)) {\n        // try to just invoke function;\n        app._state = await opts.init();\n      } else {\n        app._state = opts.init || {};\n      }\n\n      if (opts.debug) {\n        console.log(\"Initial app state\", app._state);\n      }\n\n      window.onpopstate = async () => {\n        await app.navigate(window.location.pathname);\n      };\n\n      app.global = opts.global;\n      window[opts.global] = window[opts.global] || {};\n\n      window[opts.global].navigate = async (pathName) => {\n        window.history.pushState(\n          {},\n          pathName,\n          window.location.origin + pathName\n        );\n        await app.navigate(pathName);\n      };\n\n      window[opts.global].dispatch = app.dispatch.bind(app);\n\n      await app.boot();\n\n      await app.navigate(window.location.pathname);\n\n      return app;\n    } catch (e) {\n      return { ok: false, error: e };\n    }\n  };\n\n  app.el = opts.node || document.body;\n\n  // Expects plugins in array format plugins: [[plugin1, options1], [plugin2, options2]]\n  if (opts.plugins && rules.isArray(opts.plugins)) {\n    opts.plugins.forEach((plugin) => {\n      app.plugin(plugin[0], plugin.length > 1 ? plugin[1] : {});\n    });\n  }\n\n  // set the app context\n  app.ctx = getProxy(app);\n\n  if (opts.node && (rules.isElement(opts.node) || rules.isNode(opts.node))) {\n    return mount(opts.node);\n  }\n\n  return mount(document.body);\n};\n"],"names":["rules","isArray","o","Array","isString","isEmptyObject","name","hasOwnProperty","isFunc","isAsyncFunc","fn","constructor","isNode","Node","nodeType","nodeName","isElement","HTMLElement","_catch","body","recover","result","e","then","defaultOptions","global","appName","metaTitlePrepend","routes","notFoundRouteName","notFoundUrl","options","opts","Object","assign","cache","/","view","notfound","error","routeErrors","x","keys","length","Error","getProxy","app","builtins","setState","getState","dispatch","listen","refresh","_plugins","reduce","prev","next","plugin","api","ref","namespace","el","document","_currentPath","_currentRoute","_state","_listeners","ok","install","window","ctx","installed","err","console","onError","args","key","value","oldState","freeze","JSON","parse","stringify","newState","forEach","listener","replaceState","type","apply","handler","push","idx","indexOf","splice","navigate","renderView","state","meta","title","detail","innerHTML","initRoute","route","proxy","init","unmountRoute","unmount","routeInit","pathName","force","refreshOnly","prevPath","query","params","setRoute","path","xtra","from","to","location","search","slice","split","curr","t","decodeURIComponent","tokens","found","filter","n","undefined","boot","mount","debug","log","onpopstate","pathname","history","pushState","origin","bind","querySelector","node","plugins"],"mappings":"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"}