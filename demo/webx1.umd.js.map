{"version":3,"file":"webx1.umd.js","sources":["../src/utils/rules.js","../src/utils/dom.js","../src/index.js"],"sourcesContent":["import { isNode, isElement } from \"./dom\";\n\nconst rules = {\n  isArray: (o) => {\n    return Array.isArray(o);\n  },\n  isString: (o) => {\n    return o !== null && typeof o === \"string\";\n  },\n  isEmptyObject: (o) => {\n    var name;\n    for (name in o) {\n      if (o.hasOwnProperty(name)) return false;\n    }\n    return true;\n  },\n  isFunc: (o) => {\n    return typeof o === \"function\";\n  },\n  isAsyncFunc: (fn) => {\n    return rules.isFunc(fn) && fn.constructor.name === \"AsyncFunction\";\n  },\n  isNode,\n  isElement,\n};\n\nexport default rules;\n","export const addClass = (cls, el) => {\n  if (!cls || !el) {\n    return;\n  }\n  if (typeof cls === \"string\") {\n    el.classList.add.apply(el.classList, cls.split(\" \"));\n  } else if (Array.isArray(cls)) {\n    el.classList.add.apply(el.classList, cls);\n  }\n};\n\nconst _removeClassArr = (arr, el) => {\n  arr.forEach((cls) => {\n    if (el.classList.contains(cls)) {\n      el.classList.remove(cls);\n    }\n  });\n};\n\nexport const removeClass = (cls, el) => {\n  if (!cls || !el) {\n    return;\n  }\n  if (typeof cls === \"string\") {\n    _removeClassArr(cls.split(\" \"), el);\n  } else if (Array.isArray(cls)) {\n    _removeClassArr(cls, el);\n  }\n};\n\nexport const isNode = (o) => {\n    return typeof Node === \"object\"\n      ? o instanceof Node\n      : o &&\n          typeof o === \"object\" &&\n          typeof o.nodeType === \"number\" &&\n          typeof o.nodeName === \"string\";\n  }\n\nexport const isElement = (o) => {\n    return typeof HTMLElement === \"object\"\n      ? o instanceof HTMLElement //DOM2\n      : o &&\n          typeof o === \"object\" &&\n          o !== null &&\n          o.nodeType === 1 &&\n          typeof o.nodeName === \"string\";\n  }\n\nexport const isDomObject = (o) => isNode(o) || isElement(o);\n\nexport const sanitizeHtml = (html) => {\n    var el = document.createElement('div');\n    el.innerText = html;\n    return el.innerHTML;\n}\n\nexport const createElement = (str, multi = false) => {\n    var frag = document.createRange().createContextualFragment(str);\n    let el = frag.firstElementChild;\n    return multi ? frag : el;\n}\n\nexport const setFormValue = (el, val) => {\n    if (!el) return;\n    if (el.type === 'checkbox' || el.type === 'radio') {\n        el.checked = el.value == val;\n    } else if (el.type === 'select') {\n        let opt = el.options.filter(o => o.value == val)[0];\n        if (opt) {\n            el.selectedIndex = el.options.indexOf(opt);\n        }\n    } else {\n        el.value = val;\n    }    \n}","import rules from \"./utils/rules\";\n\nconst defaultOptions = {\n  debug: false,\n  global: \"$\",\n  appName: \"App\",\n  metaTitlePrepend: \"\",\n  routes: {},\n  notFoundRouteName: \"notfound\",\n  notFoundUrl: \"/notfound\",\n};\n\nexport default async (options) => {\n  let opts = Object.assign({}, defaultOptions, options);\n\n  let cache = {\n    views: {},\n    _routes: {},\n    _computed: {},\n    routes: {\n      \"/\": () => ({\n        view: `<div>Webx Rocks!</div>`,\n      }),\n      [\"/notfound\"]: () => ({\n        view: `<div>404 Not Found!</div>`,\n      }),\n      [\"/error\"]: () => ({\n        view: \"<div>An error has occurred!</div>\",\n      }),\n    },\n  };\n\n  // routes\n  // if (!rules.isEmptyObject(opts.routes)) {\n  //   // prevalidate routes\n  //   let routeErrors = {};\n  //   for (var x in opts.routes) {\n  //     if (opts.routes.hasOwnProperty(x)) {\n  //       let route = opts.routes[x];\n  //       if (rules.isFunc(route)) {\n  //         route = await route() || { view: () => `<div>???</div>`, name: 'missing' }\n  //         // default export check\n  //         if (!route.view) {\n  //           if (route.default) {\n  //             route = route.default;\n  //           }\n  //         }\n  //       }\n  //       if (!route.view) {\n  //         routeErrors[x] = [`A view property is required for route \"${x}\"`];\n  //       }\n  //     }\n  //   }\n  //   if (Object.keys(routeErrors).length) {\n  //     if (opts.debug) {\n  //       Object.values(routeErrors).forEach(val => console.error(val));\n  //     }\n  //     throw new Error(\"Invalid route configuration\", routeErrors);\n  //   }\n  //}\n  cache.routes = Object.assign({}, cache.routes, opts.routes);\n\n  const getRoute = async (route) => {\n    if (opts.debug) {\n      console.log(`[debug] Resolving route`, route, rules.isString(route));\n    }\n    let rt = route;\n    if (rules.isString(route)) {\n      if (cache._routes[route]) {\n        opts.debug\n          ? console.log(`[debug] ${route} resolved from cache.`)\n          : null;\n        return cache._routes[route];\n      }\n\n      rt = cache.routes[route];\n    }\n\n    if (!rules.isFunc(rt)) {\n      cache._routes[route] = rt;\n      return rt;\n    }\n\n    let current = await rt();\n\n    if (!current) {\n      return null;\n    }\n\n    if (current.default) {\n      cache._routes;\n    }\n\n    cache._routes[route] = current.default ? current.default : current;\n    return cache._routes[route];\n  };\n\n  const getProxy = (app) => {\n    let builtins = {\n      setState: app.setState,\n      getState: app.getState,\n      dispatch: app.dispatch,\n      listen: app.listen,\n      refresh: app.refresh,\n      computed: (name) => {\n        let prop = app._computed[name];\n        if (!prop) {\n          return null;\n        }\n        return prop[0](app.getState());\n      },\n    };\n\n    // Add plugin api's to proxy\n    return Object.keys(app._plugins).reduce((prev, next) => {\n      let plugin = app._plugins[next];\n      if (plugin.api) {\n        let ref = plugin.namespace ? plugin.namespace : plugin.name;\n        if (!prev[ref]) {\n          prev[ref] = plugin.api;\n        } else {\n          prev[ref] = Object.assign(prev[ref], plugin.api);\n        }\n      }\n      return prev;\n    }, builtins);\n  };\n\n  const app = {\n    debug: opts.debug,\n    el: document.body,\n    _currentPath: null,\n    _currentRoute: null,\n    _state: {},\n    _listeners: [],\n    _plugins: {},\n    _computed: {},\n    routes: { ...cache.routes },\n    route: null,\n    ok: true,\n    plugin: async (plugin, options = {}) => {\n      if (!plugin.name) {\n        throw new Error(\"A plugin must have a name property.\");\n      }\n      if (!plugin.install || !rules.isFunc(plugin.install)) {\n        throw new Error(\"A plugin must define an install method.\");\n      }\n      if (app._plugins[plugin.name]) {\n        throw new Error(\n          `A plugin with the name: \"${plugin.name} is already registered.\"`\n        );\n      }\n      app._plugins[plugin.name] = plugin;\n      try {\n        let api = await plugin.install(app, options);\n        opts.debug\n          ? console.log(`[debug] Plugin \"${plugin.name}\" installed.`)\n          : null;\n        if (api) {\n          app._plugins[plugin.name].api = api;\n          // Add to window global\n          if (plugin.global) {\n            if (!window[plugin.global]) {\n              window[plugin.global] = api;\n            } else {\n              window[plugin.global] = Object.assign(window[plugin.global], api);\n            }\n          }\n          // Update app context\n          app.ctx = getProxy(app);\n        }\n        if (options.installed && rules.isFunc(options.installed)) {\n          await options.installed(plugin.name, api);\n        }\n      } catch (err) {\n        console.error(`Plugin \"${plugin.name}\" failed to install.`, err);\n        if (options.onError && rules.isFunc(options.onError)) {\n          options.onError(err);\n        }\n        delete app._plugins[plugin.name];\n      }\n    },\n    getRoute,\n    getState: (...args) => {\n      let computedState = Object.keys(app._computed).reduce((prev, next) => {\n        const [stateFn, changeFn] = app._computed[next];\n\n        let run = !changeFn || !changeFn({ ...app._state, ...prev }, app.route);\n\n        if (!run && !cache._computed[next]) {\n          // not cached\n          run = true;\n        }\n\n        if (run) {\n          prev[next] = stateFn({ ...app._state, ...prev }, app.route);\n          // only cache if a changeFn in supplied\n          if (changeFn) {\n            cache._computed[next] = JSON.parse(JSON.stringify(prev[next]));\n          }\n        }\n\n        return prev;\n      }, {});\n\n      let appState = { ...app._state, ...computedState };\n\n      if (args.length) {\n        return appState[args[0]];\n      }\n      return appState;\n    },\n    setState: (key, value) => {\n      let oldState = Object.freeze(JSON.parse(JSON.stringify(app.getState())));\n      app._state[key] = value;\n      // change listeners\n      app._listeners.forEach((listener) => {\n        listener(\"stateChange\", app.getState(), oldState, key, value);\n      });\n    },\n    replaceState: (newState) => {\n      let oldState = Object.freeze(JSON.parse(JSON.stringify(app.getState())));\n      app._state = newState;\n      app._listeners.forEach((listener) => {\n        listener(\"stateChange\", app.getState(), oldState, \"*\", newState);\n      });\n    },\n    computed: (propName, fn, changeFn) => {\n      if (app._computed[propName]) {\n        throw new Error(\n          `A computed property named \"${propName}\" already exits!`\n        );\n      }\n      if (!rules.isFunc(fn)) {\n        throw new Error(`A computed property expects a function.`);\n      }\n      app._computed[propName] = [fn, changeFn];\n    },\n    dispatch: (type, ...args) => {\n      app._listeners.forEach((listener) => {\n        listener.apply(null, [type, ...args]);\n      });\n    },\n    listen: (handler) => {\n      if (rules.isFunc(handler)) {\n        app._listeners.push(handler);\n        return () => {\n          let idx = app._listeners.indexOf(handler);\n          if (idx !== -1) {\n            app._listeners.splice(idx, 1);\n          }\n        };\n      } else {\n        console.error(\"Listen handler must be a function\", handler);\n      }      \n    },\n    refresh: () => {\n      app\n        .navigate(app._currentPath, true, true)\n        .then(() => app.dispatch(\"refreshed\", app._currentPath));\n    },\n    renderView: async (view, state, meta) => {\n      let customRender = app.el.renderView && rules.isFunc(app.el.renderView);\n\n      // Non function views\n      if (!rules.isFunc(view)) {\n        if (customRender) {\n          app.el.renderView(view, state, meta);\n        } else {\n          app.el.innerHTML = `${view}`;\n        }\n        app.dispatch(\"view-rendered\", { detail: { view, meta } });\n        return;\n      }\n\n      if (!rules.isFunc(view)) {\n        throw new Error(\"renderView requires a function.\");\n      }\n\n      if (customRender) {\n        try {\n          await app.el.renderView(view, state, meta);\n          app.dispatch(\"view-rendered\", { detail: { view, meta } });\n        } catch (err) {\n          console.error(\"render async view error\", err);\n          app.dispatch(\"view-render-failed\", { detail: view, error: err });\n        }\n        return;\n      }\n\n      try {\n        app.el.innerHTML = await view(state);\n      } catch (err) {\n        console.error(\"Render view errror\", err);\n        app.dispatch(\"view-render-failed\", { detail: view, error: err });\n      }\n\n      if (meta) {\n        document.title = `${opts.metaTitlePrepend}${meta.title}`;\n      }\n\n      app.dispatch(\"view-rendered\", { detail: { view, meta } });\n    },\n    initRoute: async (route, state) => {\n      const proxy = getProxy(app);\n      let rt = await getRoute(route);\n\n      if (rules.isFunc(rt.init)) {\n        await rt.init(state, proxy, app.el);\n      }\n    },\n    unmountRoute: async (route) => {\n      let rt = await getRoute(route);\n      if (rt && rules.isFunc(rt.unmount)) {\n        rt.unmount(getProxy(app));\n      }\n    },\n    routeInit: async (route, state) => {\n      let rt = await getRoute(route);\n      let routeState = {};\n      if (opts.routeInit && rules.isFunc(opts.routeInit)) {\n        routeState = await opts.routeInit(rt, state, getProxy(app)) || {};\n      }\n      if (route.viewState && rules.isFunc(route.viewState)) {\n        routeState = {...routeState, ...(await route.viewState(state))}\n      }\n      return routeState;\n    },\n    navigate: async (pathName, force, refreshOnly) => {\n      // don't fire same route unless forced\n      if (!force && app._currentPath && app._currentPath === pathName) {\n        return false;\n      }\n      const prevPath = app._currentPath;\n      app._currentPath = pathName;\n      let query = {};\n      let params = {};\n\n      const setRoute = async (path, xtra = {}) => {\n        let route = await getRoute(path);\n\n        if (route === null) {\n          route = routes[\"/notfound\"] || {\n            view: () => `<div class=\"page\">404 Not Found</div>`,\n          };\n        }\n\n        app._currentRoute = path;\n\n        query = location.search\n          .slice(1)\n          .split(\"&\")\n          .reduce((prev, curr) => {\n            let t = curr.split(\"=\");\n            if (t[0]) {\n              prev[t[0]] = decodeURIComponent(t[1] || \"\");\n            }\n            return prev;\n          }, {});\n\n        app.route = {\n          name: route.name,\n          match: path,\n          path: pathName,\n          meta: route.meta,\n          query,\n          params: xtra.params || {},\n        };\n\n        let state = { ...app.getState(), ...xtra, query, path };\n\n        // Pre-render hook\n        if (!refreshOnly) {\n          try {\n            let routeState = await app.routeInit(route, state);\n            if (routeState && !rules.isEmptyObject(routeState)) {\n              state = { ...state, ...routeState };\n            }\n          } catch (err) {\n            console.error(\"Pre-render failed:\", err);\n          }\n        }\n\n        // Render view\n        try {\n          await app.renderView(route.view, state, route.meta);\n        } catch (err) {\n          console.error(\"Render view failed\", err);\n        }\n\n        // Initialize route\n        try {\n          await app.initRoute(route, state);\n        } catch (err) {\n          console.error(\n            `Init route for \"${route.name ? route.name : path}\" failed`,\n            err\n          );\n        }\n\n        const { params = {} } = xtra;\n\n        if (!refreshOnly) {\n          app._listeners.forEach((listener) => {\n            listener(\"pageChange\", {\n              from: prevPath,\n              to: app._currentRoute,\n              params,\n              query,\n            });\n          });\n        }\n      };\n\n      //const { routes } = app;\n\n      // Unmount current route, if any\n      if (!refreshOnly) {\n        if (app._currentRoute) {\n          app.unmountRoute(await getRoute(app._currentRoute));\n        }\n      }\n\n      // exact match\n      if (await getRoute(pathName)) {\n        app._currentRoute = pathName;\n        await setRoute(pathName);\n        return { path: pathName, route: pathName, query, params };\n      }\n\n      // param route w/fuzzy match logic\n      let tokens = pathName.split(\"/\").slice(1);\n      let found = Object.keys(cache.routes).filter((x) => {\n        return (\n          x.indexOf(`/${tokens[0]}`) !== -1 &&\n          x.split(\"/\").slice(1).length === tokens.length\n        );\n      })[0];\n\n      if (found) {\n        found\n          .split(\"/\")\n          .slice(2)\n          .forEach((n, x) => {\n            params[n.slice(1)] = tokens[x + 1];\n          });\n        await setRoute(found, { params });\n        return { path: pathName, route: found, query, params };\n      }\n      // Not found\n      app._currentRoute = opts.notFoundRouteName;\n      await setRoute(opts.notFoundUrl);\n      return { path: pathName, route: undefined, query, params };\n    },\n    boot: async () => {\n      // Runs on startup. Intended to be monkey patched in plugins.\n    },\n  };\n\n  const mount = async (el) => {\n    try {\n      if (rules.isString(el)) {\n        app.el = document.querySelector(el);\n        if (!app.el) {\n          throw new Error(`Invalid mount target: ${el}. Missing from the DOM.`);\n        }\n      } else {\n        if (!rules.isNode(el) || !rules.isElement(el)) {\n          throw new Error(\"Invalid DOM object for mount.\");\n        }\n        app.el = el;\n      }\n\n      if (rules.isFunc(opts.init)) {\n        // try to just invoke function;\n        app._state = await opts.init();\n      } else {\n        app._state = opts.init || {};\n      }\n\n      if (opts.debug) {\n        console.log(\"[debug] Initial app state\", app.getState());\n      }\n\n      window.onpopstate = async () => {\n        await app.navigate(window.location.pathname);\n      };\n\n      app.global = opts.global;\n      window[opts.global] = window[opts.global] || {};\n\n      window[opts.global].navigate = async (pathName) => {\n        window.history.pushState(\n          {},\n          pathName,\n          window.location.origin + pathName\n        );\n        await app.navigate(pathName);\n      };\n\n      window[opts.global].dispatch = app.dispatch.bind(app);\n\n      await app.boot(getProxy(app));\n\n      await app.navigate(window.location.pathname);\n\n      return app;\n    } catch (e) {\n      return { ok: false, error: e };\n    }\n  };\n\n  // computed\n  // Expected format 'name': [stateFunc, runFunc]\n  if (opts.computed) {\n    Object.keys(opts.computed).forEach((compKey) => {\n      opts.debug\n        ? console.log(`[debug] Adding computed property \"${compKey}\".`)\n        : null;\n      app.computed(\n        compKey,\n        opts.computed[compKey][0],\n        opts.computed[compKey][1]\n      );\n    });\n  }\n\n  app.el = opts.node || document.body;\n\n  // Expects plugins in array format plugins: [[plugin1, options1], [plugin2, options2]]\n  if (opts.plugins && rules.isArray(opts.plugins)) {\n    opts.plugins.forEach(async (plugin) => {\n      await app.plugin(plugin[0], plugin.length > 1 ? plugin[1] : {});\n    });\n  }\n\n  // set the app context\n  app.ctx = getProxy(app);\n\n  if (opts.node && (rules.isElement(opts.node) || rules.isNode(opts.node))) {\n    return mount(opts.node);\n  }\n\n  return mount(document.body);\n};\n"],"names":["rules","isArray","o","Array","isString","isEmptyObject","name","hasOwnProperty","isFunc","isAsyncFunc","fn","constructor","isNode","Node","nodeType","nodeName","isElement","HTMLElement","_catch","body","recover","result","e","then","defaultOptions","debug","global","appName","metaTitlePrepend","routes","notFoundRouteName","notFoundUrl","options","opts","Object","assign","cache","views","_routes","_computed","/","view","getRoute","route","console","log","rt","current","getProxy","app","builtins","setState","getState","dispatch","listen","refresh","computed","prop","keys","_plugins","reduce","prev","next","plugin","api","ref","namespace","el","document","_currentPath","_currentRoute","_state","_listeners","ok","Error","install","window","ctx","installed","err","error","onError","args","computedState","stateFn","changeFn","run","JSON","parse","stringify","appState","length","key","value","oldState","freeze","forEach","listener","replaceState","newState","propName","type","apply","handler","push","idx","indexOf","splice","navigate","renderView","state","meta","title","detail","innerHTML","customRender","initRoute","proxy","init","unmountRoute","unmount","routeInit","viewState","routeState","_opts$routeInit","pathName","force","refreshOnly","setRoute","path","undefined","query","params","tokens","split","slice","found","filter","x","n","prevPath","xtra","from","to","location","search","curr","t","decodeURIComponent","match","_unmountRoute2","boot","mount","onpopstate","pathname","history","pushState","origin","bind","querySelector","compKey","node","plugins"],"mappings":"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"}