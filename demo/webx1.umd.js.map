{"version":3,"file":"webx1.umd.js","sources":["../src/utils/rules.js","../src/utils/dom.js","../src/index.js"],"sourcesContent":["import { isNode, isElement } from \"./dom\";\n\nconst rules = {\n  isArray: (o) => {\n    return Array.isArray(o);\n  },\n  isString: (o) => {\n    return o !== null && typeof o === \"string\";\n  },\n  isEmptyObject: (o) => {\n    var name;\n    for (name in o) {\n      if (o.hasOwnProperty(name)) return false;\n    }\n    return true;\n  },\n  isFunc: (o) => {\n    return typeof o === \"function\";\n  },\n  isAsyncFunc: (fn) => {\n    return rules.isFunc(fn) && fn.constructor.name === \"AsyncFunction\";\n  },\n  isNode,\n  isElement,\n};\n\nexport default rules;\n","export const addClass = (cls, el) => {\n  if (!cls || !el) {\n    return;\n  }\n  if (typeof cls === \"string\") {\n    el.classList.add.apply(el.classList, cls.split(\" \"));\n  } else if (Array.isArray(cls)) {\n    el.classList.add.apply(el.classList, cls);\n  }\n};\n\nconst _removeClassArr = (arr, el) => {\n  arr.forEach((cls) => {\n    if (el.classList.contains(cls)) {\n      el.classList.remove(cls);\n    }\n  });\n};\n\nexport const removeClass = (cls, el) => {\n  if (!cls || !el) {\n    return;\n  }\n  if (typeof cls === \"string\") {\n    _removeClassArr(cls.split(\" \"), el);\n  } else if (Array.isArray(cls)) {\n    _removeClassArr(cls, el);\n  }\n};\n\nexport const isNode = (o) => {\n    return typeof Node === \"object\"\n      ? o instanceof Node\n      : o &&\n          typeof o === \"object\" &&\n          typeof o.nodeType === \"number\" &&\n          typeof o.nodeName === \"string\";\n  }\n\nexport const isElement = (o) => {\n    return typeof HTMLElement === \"object\"\n      ? o instanceof HTMLElement //DOM2\n      : o &&\n          typeof o === \"object\" &&\n          o !== null &&\n          o.nodeType === 1 &&\n          typeof o.nodeName === \"string\";\n  }\n\nexport const isDomObject = (o) => isNode(o) || isElement(o);\n\nexport const sanitizeHtml = (html) => {\n    var el = document.createElement('div');\n    el.innerText = html;\n    return el.innerHTML;\n}\n\nexport const createElement = (str, multi = false) => {\n    var frag = document.createRange().createContextualFragment(str);\n    let el = frag.firstElementChild;\n    return multi ? frag : el;\n}\n\nexport const setFormValue = (el, val) => {\n    if (!el) return;\n    if (el.type === 'checkbox' || el.type === 'radio') {\n        el.checked = el.value == val;\n    } else if (el.type === 'select') {\n        let opt = el.options.filter(o => o.value == val)[0];\n        if (opt) {\n            el.selectedIndex = el.options.indexOf(opt);\n        }\n    } else {\n        el.value = val;\n    }    \n}","import rules from \"./utils/rules\";\n\nconst defaultOptions = {\n  debug: false,\n  global: \"$\",\n  appName: \"App\",\n  metaTitlePrepend: \"\",\n  routes: {},\n  notFoundRouteName: \"notfound\",\n  notFoundUrl: \"/notfound\",\n};\n\nexport default async (options) => {\n  let opts = Object.assign({}, defaultOptions, options);\n\n  let cache = {\n    views: {},\n    _routes: {},\n    _computed: {},\n    _waiting: { plugins: [] },\n    routes: {\n      \"/\": () => ({\n        view: `<div>Webx Rocks!</div>`,\n      }),\n      [\"/notfound\"]: () => ({\n        view: `<div>404 Not Found!</div>`,\n      }),\n      [\"/error\"]: () => ({\n        view: \"<div>An error has occurred!</div>\",\n      }),\n    },\n  };\n\n  // routes\n  // if (!rules.isEmptyObject(opts.routes)) {\n  //   // prevalidate routes\n  //   let routeErrors = {};\n  //   for (var x in opts.routes) {\n  //     if (opts.routes.hasOwnProperty(x)) {\n  //       let route = opts.routes[x];\n  //       if (rules.isFunc(route)) {\n  //         route = await route() || { view: () => `<div>???</div>`, name: 'missing' }\n  //         // default export check\n  //         if (!route.view) {\n  //           if (route.default) {\n  //             route = route.default;\n  //           }\n  //         }\n  //       }\n  //       if (!route.view) {\n  //         routeErrors[x] = [`A view property is required for route \"${x}\"`];\n  //       }\n  //     }\n  //   }\n  //   if (Object.keys(routeErrors).length) {\n  //     if (opts.debug) {\n  //       Object.values(routeErrors).forEach(val => console.error(val));\n  //     }\n  //     throw new Error(\"Invalid route configuration\", routeErrors);\n  //   }\n  //}\n  cache.routes = Object.assign({}, cache.routes, opts.routes);\n\n  const getRoute = async (route) => {\n    if (opts.debug) {\n      console.log(`[debug] Resolving route`, route, rules.isString(route));\n    }\n    let rt = route;\n    if (rules.isString(route)) {\n      if (cache._routes[route]) {\n        opts.debug\n          ? console.log(`[debug] ${route} resolved from cache.`)\n          : null;\n        return cache._routes[route];\n      }\n\n      rt = cache.routes[route];\n    }\n\n    if (!rules.isFunc(rt)) {\n      cache._routes[route] = rt;\n      return rt;\n    }\n\n    let current = await rt();\n\n    if (!current) {\n      return null;\n    }\n\n    if (current.default) {\n      cache._routes;\n    }\n\n    cache._routes[route] = current.default ? current.default : current;\n    return cache._routes[route];\n  };\n\n  const getProxy = (app) => {\n    let builtins = {\n      setState: app.setState,\n      getState: app.getState,\n      dispatch: app.dispatch,\n      listen: app.listen,\n      refresh: app.refresh,\n      computed: (name) => {\n        let prop = app._computed[name];\n        if (!prop) {\n          return null;\n        }\n        return prop[0](app.getState());\n      },\n    };\n\n    // Add plugin api's to proxy\n    return Object.keys(app._plugins).reduce((prev, next) => {\n      let plugin = app._plugins[next];\n      if (plugin.api) {\n        let ref = plugin.namespace ? plugin.namespace : plugin.name;\n        if (!prev[ref]) {\n          prev[ref] = plugin.api;\n        } else {\n          prev[ref] = Object.assign(prev[ref], plugin.api);\n        }\n      }\n      return prev;\n    }, builtins);\n  };\n\n  const app = {\n    debug: opts.debug,\n    el: document.body,\n    _currentPath: null,\n    _currentRoute: null,\n    _state: {},\n    _listeners: [],\n    _plugins: {},\n    _computed: {},\n    routes: { ...cache.routes },\n    route: null,\n    ok: true,\n    plugin: async (plugin, options = {}) => {\n      if (!plugin.name) {\n        throw new Error(\"A plugin must have a name property.\");\n      }\n      if (!plugin.install || !rules.isFunc(plugin.install)) {\n        throw new Error(\"A plugin must define an install method.\");\n      }\n      if (app._plugins[plugin.name]) {\n        throw new Error(\n          `A plugin with the name: \"${plugin.name} is already registered.\"`\n        );\n      }\n      app._plugins[plugin.name] = plugin;\n      try {\n        let api = await plugin.install(app, options);\n        opts.debug\n          ? console.log(`[debug] Plugin \"${plugin.name}\" installed.`)\n          : null;\n        if (api) {\n          app._plugins[plugin.name].api = api;\n          // Add to window global\n          if (plugin.global) {\n            if (!window[plugin.global]) {\n              window[plugin.global] = api;\n            } else {\n              window[plugin.global] = Object.assign(window[plugin.global], api);\n            }\n          }\n          // Update app context\n          app.ctx = getProxy(app);\n        }\n        if (options.installed && rules.isFunc(options.installed)) {\n          await options.installed(plugin.name, api);\n        }\n      } catch (err) {\n        console.error(`Plugin \"${plugin.name}\" failed to install.`, err);\n        if (options.onError && rules.isFunc(options.onError)) {\n          options.onError(err);\n        }\n        delete app._plugins[plugin.name];\n      }\n    },\n    waitForPlugin: (name, handler) => {\n      if (app.ctx && app.ctx[name]) {\n        handler(app.ctx[name], app);\n        return;\n      }\n      if (!cache._waiting.hasOwnProperty(name)) {\n        cache._waiting[name] = [];\n      }\n      cache._waiting[name].push(handler);\n    },\n    getRoute,\n    getState: (...args) => {\n      let computedState = Object.keys(app._computed).reduce((prev, next) => {\n        const [stateFn, changeFn] = app._computed[next];\n\n        let run = !changeFn || !changeFn({ ...app._state, ...prev }, app.route);\n\n        if (!run && !cache._computed[next]) {\n          // not cached\n          run = true;\n        }\n\n        if (run) {\n          prev[next] = stateFn({ ...app._state, ...prev }, app.route);\n          // only cache if a changeFn in supplied\n          if (changeFn) {\n            cache._computed[next] = JSON.parse(JSON.stringify(prev[next]));\n          }\n        }\n\n        return prev;\n      }, {});\n\n      let appState = { ...app._state, ...computedState };\n\n      if (args.length) {\n        return appState[args[0]];\n      }\n      return appState;\n    },\n    setState: (key, value) => {\n      let oldState = Object.freeze(JSON.parse(JSON.stringify(app.getState())));\n      app._state[key] = value;\n      // change listeners\n      app._listeners.forEach((listener) => {\n        listener(\"stateChange\", app.getState(), oldState, key, value);\n      });\n    },\n    replaceState: (newState) => {\n      let oldState = Object.freeze(JSON.parse(JSON.stringify(app.getState())));\n      app._state = newState;\n      app._listeners.forEach((listener) => {\n        listener(\"stateChange\", app.getState(), oldState, \"*\", newState);\n      });\n    },\n    computed: (propName, fn, changeFn) => {\n      if (app._computed[propName]) {\n        throw new Error(\n          `A computed property named \"${propName}\" already exits!`\n        );\n      }\n      if (!rules.isFunc(fn)) {\n        throw new Error(`A computed property expects a function.`);\n      }\n      app._computed[propName] = [fn, changeFn];\n    },\n    dispatch: (type, ...args) => {\n      app._listeners.forEach((listener) => {\n        listener.apply(null, [type, ...args]);\n      });\n    },\n    listen: (handler) => {\n      if (rules.isFunc(handler)) {\n        app._listeners.push(handler);\n        return () => {\n          let idx = app._listeners.indexOf(handler);\n          if (idx !== -1) {\n            app._listeners.splice(idx, 1);\n          }\n        };\n      } else {\n        console.error(\"Listen handler must be a function\", handler);\n      }\n    },\n    refresh: () => {\n      app\n        .navigate(app._currentPath, true, true)\n        .then(() => app.dispatch(\"refreshed\", app._currentPath));\n    },\n    renderView: async (view, state, meta) => {\n      let customRender = app.el.renderView && rules.isFunc(app.el.renderView);\n\n      if (app.debug) {\n        console.log(\"[debug] rendering view\", view, state, meta);\n      }\n\n      // Non function views\n      if (!rules.isFunc(view)) {\n        if (customRender) {\n          app.el.renderView(view, state, meta);\n        } else {\n          app.el.innerHTML = `${view}`;\n        }\n        app.dispatch(\"view-rendered\", { detail: { view, meta } });\n        return;\n      }\n\n      if (!rules.isFunc(view)) {\n        throw new Error(\"renderView requires a function.\");\n      }\n\n      if (customRender) {\n        try {\n          await app.el.renderView(view, state, meta);\n          app.dispatch(\"view-rendered\", { detail: { view, meta } });\n        } catch (err) {\n          console.error(\"render async view error\", err);\n          app.dispatch(\"view-render-failed\", { detail: view, error: err });\n        }\n        return;\n      }\n\n      try {\n        app.el.innerHTML = await view(state);\n      } catch (err) {\n        console.error(\"Render view errror\", err);\n        app.dispatch(\"view-render-failed\", { detail: view, error: err });\n      }\n\n      if (meta) {\n        document.title = `${opts.metaTitlePrepend}${meta.title}`;\n      }\n\n      app.dispatch(\"view-rendered\", { detail: { view, meta } });\n    },\n    initRoute: async (route, state) => {\n      const proxy = getProxy(app);\n      let rt = await getRoute(route);\n      if (rules.isFunc(rt.init)) {\n        await rt.init(state, proxy, app.el);\n      }\n    },\n    unmountRoute: async (route) => {\n      let rt = await getRoute(route);\n      if (rt && rules.isFunc(rt.unmount)) {\n        rt.unmount(getProxy(app));\n      }\n    },\n    routeInit: async (route, state) => {\n      let rt = await getRoute(route);\n      let routeState = {};\n      let proxy = getProxy(app);\n      if (opts.routeInit && rules.isFunc(opts.routeInit)) {\n        routeState = (await opts.routeInit(rt, state, proxy)) || {};\n      }\n      if (route.viewState && rules.isFunc(route.viewState)) {\n        routeState = {\n          ...routeState,\n          ...(await route.viewState(state, proxy)),\n        };\n      }\n      return routeState;\n    },\n    navigate: async (pathName, force, refreshOnly) => {\n      // don't fire same route unless forced\n      if (!force && app._currentPath && app._currentPath === pathName) {\n        return false;\n      }\n      const prevPath = app._currentPath;\n      app._currentPath = pathName;\n      let query = {};\n      let params = {};\n\n      const setRoute = async (path, xtra = {}) => {\n        let route = await getRoute(path);\n\n        if (route === null) {\n          route = routes[\"/notfound\"] || {\n            view: () => `<div class=\"page\">404 Not Found</div>`,\n          };\n        }\n\n        app._currentRoute = path;\n\n        query = location.search\n          .slice(1)\n          .split(\"&\")\n          .reduce((prev, curr) => {\n            let t = curr.split(\"=\");\n            if (t[0]) {\n              prev[t[0]] = decodeURIComponent(t[1] || \"\");\n            }\n            return prev;\n          }, {});\n\n        app.route = {\n          name: route.name,\n          match: path,\n          path: pathName,\n          meta: route.meta,\n          query,\n          params: xtra.params || {},\n        };\n\n        let state = { ...app.getState(), ...xtra, query, path };\n\n        // Pre-render hook\n        if (!refreshOnly) {\n          try {\n            let routeState = await app.routeInit(route, state);\n            if (routeState && !rules.isEmptyObject(routeState)) {\n              state = { ...state, ...routeState };\n            }\n          } catch (err) {\n            console.error(\"Pre-render failed:\", err);\n          }\n        } else {\n          // view state\n          if (route.viewState && rules.isFunc(route.viewState)) {\n            state = {\n              ...state,\n              ...(await route.viewState(state, getProxy(app))),\n            };\n          }\n        }\n\n        // Render view\n        try {\n          await app.renderView(route.view, state, route.meta);\n        } catch (err) {\n          console.error(\"Render view failed\", err);\n        }\n\n        // Initialize route\n        try {\n          await app.initRoute(route, state);\n        } catch (err) {\n          console.error(\n            `Init route for \"${route.name ? route.name : path}\" failed`,\n            err\n          );\n        }\n\n        const { params = {} } = xtra;\n\n        if (!refreshOnly) {\n          app._listeners.forEach((listener) => {\n            listener(\"pageChange\", {\n              from: prevPath,\n              to: app._currentRoute,\n              params,\n              query,\n            });\n          });\n        }\n      };\n\n      //const { routes } = app;\n\n      // Unmount current route, if any\n      if (!refreshOnly) {\n        if (app._currentRoute) {\n          app.unmountRoute(await getRoute(app._currentRoute));\n        }\n      }\n\n      // exact match\n      if (await getRoute(pathName)) {\n        app._currentRoute = pathName;\n        await setRoute(pathName);\n        return { path: pathName, route: pathName, query, params };\n      } else {\n        // param route w/fuzzy match logic\n        let tokens = pathName.split(\"/\").slice(1);\n        let found = Object.keys(cache.routes).filter((x) => {\n          return (\n            x.indexOf(`/${tokens[0]}`) !== -1 &&\n            x.split(\"/\").slice(1).length === tokens.length\n          );\n        })[0];\n\n        if (found) {\n          found\n            .split(\"/\")\n            .slice(2)\n            .forEach((n, x) => {\n              params[n.slice(1)] = tokens[x + 1];\n            });\n          await setRoute(found, { params });\n          return { path: pathName, route: found, query, params };\n        } else {\n          // Not found\n          app._currentRoute = opts.notFoundRouteName;\n          await setRoute(opts.notFoundUrl);\n          return { path: pathName, route: undefined, query, params };\n        }\n      }\n    },\n    boot: async () => {\n      // Runs on startup. Intended to be monkey patched in plugins.\n    },\n  };\n\n  const mount = async (el) => {\n    try {\n      if (rules.isString(el)) {\n        app.el = document.querySelector(el);\n        if (!app.el) {\n          throw new Error(`Invalid mount target: ${el}. Missing from the DOM.`);\n        }\n      } else {\n        if (!rules.isNode(el) || !rules.isElement(el)) {\n          throw new Error(\"Invalid DOM object for mount.\");\n        }\n        app.el = el;\n      }\n\n      if (rules.isFunc(opts.init)) {\n        // try to just invoke function;\n        app._state = await opts.init();\n      } else {\n        app._state = opts.init || {};\n      }\n\n      if (opts.debug) {\n        console.log(\"[debug] Initial app state\", app.getState());\n      }\n\n      app.global = opts.global;\n      window[opts.global] = window[opts.global] || {};\n\n      window[opts.global].navigate = async (pathName) => {\n        window.history.pushState(\n          {},\n          pathName,\n          window.location.origin + pathName\n        );\n        await app.navigate(pathName);\n      };\n\n      window[opts.global].dispatch = app.dispatch.bind(app);\n\n      await app.boot(getProxy(app));\n\n      await app.navigate(window.location.pathname);\n\n      return app;\n    } catch (e) {\n      return { ok: false, error: e };\n    }\n  };\n\n  // computed\n  // Expected format 'name': [stateFunc, runFunc]\n  if (opts.computed) {\n    Object.keys(opts.computed).forEach((compKey) => {\n      opts.debug\n        ? console.log(`[debug] Adding computed property \"${compKey}\".`)\n        : null;\n      app.computed(\n        compKey,\n        opts.computed[compKey][0],\n        opts.computed[compKey][1]\n      );\n    });\n  }\n\n  app.el = opts.node || document.body;\n\n  // Expects plugins in array format plugins: [[plugin1, options1], [plugin2, options2]]\n  if (opts.plugins && rules.isArray(opts.plugins)) {\n    opts.plugins.forEach(async (plugin) => {\n      await app.plugin(plugin[0], plugin.length > 1 ? plugin[1] : {});\n    });\n  }\n\n  // set the app context\n  app.ctx = getProxy(app);\n\n  // waiting for plugins\n  Object.keys(cache._waiting.plugins).forEach((key) => {\n    let waiting = cache._waiting[key];\n    let plugin = app.ctx[key];\n    if (!plugin) {\n      console.warn(`Waiting for \"${key}\", but does not exist as a plugin?`);\n      return;\n    }\n    waiting.forEach((item) => {\n      item(plugin, app);\n    });\n  });\n  cache._waiting = {};\n\n  if (opts.node && (rules.isElement(opts.node) || rules.isNode(opts.node))) {\n    return mount(opts.node);\n  }\n\n  return mount(document.body);\n};\n"],"names":["rules","isArray","o","Array","isString","isEmptyObject","name","hasOwnProperty","isFunc","isAsyncFunc","fn","constructor","isNode","Node","nodeType","nodeName","isElement","HTMLElement","_catch","body","recover","result","e","then","defaultOptions","debug","global","appName","metaTitlePrepend","routes","notFoundRouteName","notFoundUrl","options","opts","Object","assign","cache","views","_routes","_computed","_waiting","plugins","/","view","getRoute","route","console","log","rt","current","getProxy","app","builtins","setState","getState","dispatch","listen","refresh","computed","prop","keys","_plugins","reduce","prev","next","plugin","api","ref","namespace","el","document","_currentPath","_currentRoute","_state","_listeners","ok","Error","install","window","ctx","installed","err","error","onError","waitForPlugin","handler","push","args","computedState","stateFn","changeFn","run","JSON","parse","stringify","appState","length","key","value","oldState","freeze","forEach","listener","replaceState","newState","propName","type","apply","idx","indexOf","splice","navigate","renderView","state","meta","title","detail","innerHTML","customRender","initRoute","proxy","init","unmountRoute","unmount","routeInit","viewState","routeState","_opts$routeInit","pathName","force","refreshOnly","setRoute","path","query","params","tokens","split","slice","found","filter","x","n","undefined","prevPath","xtra","from","to","location","search","curr","t","decodeURIComponent","match","_unmountRoute2","boot","mount","history","pushState","origin","bind","pathname","querySelector","compKey","node","item","warn"],"mappings":"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"}