{"version":3,"file":"plugins.js","sources":["../../src/plugins/nav/index.js","../../src/plugins/nav/browser.js","../../src/plugins/typer/index.js","../../src/plugins/typer/browser.js","../../src/plugins/templater/index.js","../../src/plugins/templater/browser.js"],"sourcesContent":["/*\n * Example plugin that hightlights anchors based on extra route data.\n * See routes in index.html for configuration.\n */\nexport default {\n    name: \"webx1NavPlugin\",\n    global: \"$\",\n    namespace: \"nav\",\n    install: (app, options) => {\n      let opts = Object.assign({ activeClassName: \"active \" }, options);\n  \n      let origInitRoute = app.initRoute;\n      let origUnmountRoute = app.unmountRoute;\n      let origBoot = app.boot;\n  \n      let rootEl = opts.scope ? document.querySelector(opts.scope) : app.el;\n  \n      app.initRoute = async (route, state) => {\n        await origInitRoute(route, state);\n        const routeMap = Object.keys(app.routes).reduce((prev, curr) => {\n          let rt = app.routes[curr];\n          if (rt.name) {\n            prev[rt.name] = {\n              root: rt.root,\n              path: curr,\n              activeClass: rt.activeClass || opts.activeClassName,\n            };\n          }\n          return prev;\n        }, {});\n        let links = [].slice.call(rootEl.querySelectorAll(\"a[data-route]\"));\n  \n        links.forEach((anchor) => {\n          let routeName = anchor.dataset[\"route\"];\n          let current = routeMap[routeName] || {};\n  \n          if (current.activeClassName) {\n            anchor.dataset[\"activeClass\"] = activeClass;\n          }\n  \n          anchor.addEventListener(\"click\", (e) => {\n            e.preventDefault();\n  \n            let { path, activeClass, root } =\n              routeMap[e.target.dataset[\"route\"]] || {};\n            if (path) {\n              let href = e.target.href;\n              let currPath = href.replace(window.location.origin, \"\");\n  \n              window.history.pushState({}, currPath, href);\n              app.navigate(e.target.pathname);\n  \n              let anchor = root\n                ? rootEl.querySelector(`[data-route=\"${root}\"]`)\n                : e.target;\n  \n              if (anchor) {\n                if (activeClass) {\n                  anchor.dataset[\"activeClass\"] = activeClass;\n                }\n                anchor.classList.add(activeClass || opts.activeClassName);\n              }\n            }\n          });\n        });\n      };\n  \n      app.unmountRoute = (route, state) => {\n        origUnmountRoute.call(app, route, state);\n        [].slice\n          .call(rootEl.querySelectorAll(\"a[data-route]\"))\n          .forEach((link) => {\n            let cls = link.dataset[\"activeClass\"] || opts.activeClassName;\n            link.classList.remove(cls);\n          });\n      };\n  \n      app.boot = async () => {\n        await origBoot.call(app);\n        let pathname = window.location.pathname;\n  \n        if (pathname) {\n          let currentRoute = await app.getRoute(pathname);\n          if (currentRoute && currentRoute.name) {\n            let routeName = currentRoute.root\n              ? currentRoute.root\n              : currentRoute.name;\n            let anchor = rootEl.querySelector(`[data-route=\"${routeName}\"]`);\n            if (anchor) {\n              let cls = currentRoute.activeClass || opts.activeClassName;\n              anchor.classList.add(cls);\n              anchor.dataset[\"activeClass\"] = cls;\n            }\n          }\n        }\n      };\n  \n      // API to return\n      return {\n        getRouteElements: () => {\n          return [].slice.call(rootEl.querySelectorAll(\"[data-route]\"));\n        },\n      };\n    },\n  };\n  ","import webx1NavPlugin from './index';\n\nif (typeof window !== undefined) {\n    window.webx1NavPlugin = webx1NavPlugin;\n}","const defaultOptions = { speed: 100 };\n\nexport default {\n  name: \"webx1TyperPlugin\",\n  global: \"$\",\n  namespace: \"typer\",\n  install: (app, options = {}) => {\n    let opts = Object.assign({}, defaultOptions, options);\n    let rootEl = opts.scope ? document.querySelector(opts.scope) : app.el;\n    let origInitRoute = app.initRoute;\n\n    const run = () => {\n        [].slice.call(rootEl.querySelectorAll(\"[data-typer]\")).forEach((el) => {\n            let text = el.dataset[\"typer\"] || el.textContent;\n            let speed = el.hasAttribute(\"data-speed\")\n              ? parseInt(el.dataset[\"speed\"])\n              : opts.speed;\n            typewriter(text, speed, el.hasAttribute('data-replace'), el.hasAttribute('data-repeat'), el.getAttribute('data-append')).typeIt(el, text);\n          });\n    }\n\n    app.initRoute = async (route, state) => {\n      await origInitRoute.call(app, route, state);\n        run();      \n    };\n\n    function typewriter(text, speed, replace = false, repeat = false, append = '') {\n      let i = 0;\n      let txt = text;\n      let origText = text;\n\n      if (!speed) {\n        speed = 100;\n      }\n\n      const api = {\n        typeIt: function (el, str) {\n          let ts;\n          if (str) {\n            txt = str;\n            i = 0;\n          }\n          if (el) {\n            api.el = el;\n          }\n\n          if (i < txt.length) {\n            el.textContent = replace ? txt.charAt(i) : (el.textContent + txt.charAt(i));\n            if (append) {\n                el.textContent = el.textContent + append\n            }\n            i++;\n            ts = setTimeout(api.typeIt.bind(null, el), speed);\n          } else {\n              if (repeat) {\n                  el.textContent = '';\n                  ts = setTimeout(api.typeIt.bind(null, el, origText))\n              }\n          }\n          return {\n              stop: () => {\n                  if (ts) {\n                    clearTimeout(ts);\n                  }                \n              }\n          }\n        },\n      };\n      return api;\n    }\n\n    return {\n      typeIt: (el, text, speed = opts.speed, replace) => {\n        return typewriter(text, speed, replace).typeIt(el, text);\n      },\n      run\n    };\n  },\n};\n","import webx1TyperPlugin from './index';\n\nif (typeof window !== undefined) {\n    window.webx1TyperPlugin = webx1TyperPlugin;\n}","const defaultOptions = { clobber: true };\n\nexport default {\n  name: \"webx1TemplaterPlugin\",\n  global: \"$\",\n  namespace: \"template\",\n  install: (app, options = {}) => {\n    const templateCache = {};\n    const listeners = {};\n\n    let opts = Object.assign({}, defaultOptions, options);\n    let rootEl = opts.scope ? document.querySelector(opts.scope) : app.el;\n\n    function Templater(templateText) {\n      return new Function(\n        \"page\",\n        \"var output=\" +\n          JSON.stringify(templateText)\n            .replace(/<%=(.+?)%>/g, '\"+($1)+\"')\n            .replace(/<%(.+?)%>/g, '\";$1\\noutput+=\"') +\n          \";return output;\"\n      );\n    }\n\n    const api = {\n      init: () => {\n        let templates = [].slice.call(\n          rootEl.querySelectorAll('script[type=\"text/template\"]')\n        );\n        templates.forEach((template) => {\n          let id = template.getAttribute(\"id\");\n          if (id && template.textContent) {\n            templateCache[id] = Templater(template.textContent);\n          }\n        });\n      },\n      register: (name, templateText) => {\n        if (templateCache[name]) {\n            if (!opts.clobber) {\n                throw new Error(`A template named \"${name}\" is already registered!`);\n            }\n        }\n        templateCache[name] = Templater(templateText);\n        if (listeners[name]) {\n            listeners[name].forEach(handler => {\n                handler(templateCache[name]);\n            });\n        }\n      },\n      registerFromUrl: async (name, url, onError) => {\n        if (templateCache[name] && !opts.clobber) {\n          onError\n            ? onError(\n                `A template with the name \"${name}\" is already registered!`\n              )\n            : null;\n          return;\n        }\n\n        try {\n            let res = await fetch(url);\n            let templateText = await res.text();\n            templateCache[name] = Templater(templateText);\n            if (listeners[name]) {\n                listeners[name].forEach(handler => {\n                    handler(templateCache[name]);\n                });\n            }\n        } catch (err) {\n            if (app.debug) {\n                console.error(`[webx1TemplaterPlugin] Failed to fetch remote template`, err);\n            }\n            onError && onError(err);\n        }\n      },\n      ready: (name, callback) => {\n        if (!listeners[name]) {\n            listeners[name] = [];\n        }\n        listeners[name].push(callback);\n\n        if (templateCache[name]) {\n            callback(templateCache[name]);\n        }\n      },\n      render: (name, obj) => {\n        if (!templateCache[name]) {\n          throw new Error(\n            `Unknown template \"${name}\". Did you register it first?`\n          );\n        }\n        return templateCache[name](obj);\n      },\n      renderTo(name, obj, el, callback) {\n        let elem = el;\n        if (!el) {\n          throw new Error(\"An element is required to bind!\");\n        }\n        if (typeof el === \"string\") {\n          elem = document.querySelector(el);\n        }\n\n        if (!templateCache[name]) {\n          console.warn(\n            `[webx1TemplaterPlugin] Missing template \"${name}\" on bind! Is it registered?`\n          );\n          return;\n        }\n        elem.innerHTML = templateCache[name](obj);\n        if (callback && typeof callback === \"function\") {\n          callback(el, name, obj);\n        }\n      },\n    };\n\n    return api;\n  },\n};\n","import webx1TemplaterPlugin from './index';\n\nif (typeof window !== undefined) {\n    window.webx1TemplaterPlugin = webx1TemplaterPlugin;\n}"],"names":["name","global","namespace","install","app","options","opts","Object","assign","activeClassName","origInitRoute","initRoute","origUnmountRoute","unmountRoute","origBoot","boot","rootEl","scope","document","querySelector","el","route","state","routeMap","keys","routes","reduce","prev","curr","rt","root","path","activeClass","slice","call","querySelectorAll","forEach","anchor","dataset","addEventListener","e","preventDefault","target","href","currPath","replace","window","location","origin","history","pushState","navigate","pathname","classList","add","link","remove","getRoute","currentRoute","cls","getRouteElements","undefined","webx1NavPlugin","defaultOptions","speed","webx1TyperPlugin","run","text","textContent","typewriter","hasAttribute","parseInt","getAttribute","typeIt","repeat","append","i","txt","origText","api","str","ts","length","charAt","setTimeout","bind","stop","clearTimeout","clobber","webx1TemplaterPlugin","templateCache","listeners","Templater","templateText","Function","JSON","stringify","init","template","id","register","Error","handler","registerFromUrl","url","onError","body","recover","result","fetch","res","then","err","debug","console","error","ready","callback","push","render","obj","renderTo","elem","innerHTML","warn"],"mappings":"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"}